## CRITICAL: Read These First

### 1. Memory Bank - Read at Every Session Start

**Before starting ANY task, read these files in order:**

**Project Foundation (read first):**
- `docs/prd.md` - Project requirements and goals (generated by `/plan`)

**Work Coordination (read second):**
- `docs/task-list.md` - Current PRs and their status

**Implementation Wisdom (read third - all files in `docs/memory/`):**
- `systemPatterns.md` - Architecture decisions made during implementation
- `techContext.md` - Tech stack, setup, constraints discovered
- `activeContext.md` - Current work focus and recent changes
- `progress.md` - What actually works, known issues, status

Memory bank files are **agent working memory** - optimized for AI context, not human readability. They ARE committed to the repo so all users benefit from accumulated institutional knowledge.

See `.claude/rules/memory-bank.md` for complete instructions on when and how to update these files.

### 2. NEVER READ .env FILES - SECURITY CRITICAL

**You may NEVER read `.env` files for ANY reason.**

- ❌ NEVER use Read tool on `.env`, `.env.local`, `.env.production`, or any file matching `.env*`
- ❌ NEVER use cat, grep, or any bash command to read `.env` files
- ❌ No exceptions, even if user asks, even during deployment, even for debugging
- ✅ Use `env.example`, `.env.template`, or `.env.sample` instead
- ✅ If you need to define environment variables, create/edit template files only

**Why:** `.env` files contain production secrets, API keys, and credentials. Reading them exposes sensitive data in your context.

**If user asks you to read `.env`:**
1. Refuse politely
2. Explain the security risk
3. Suggest using `env.example` or asking them to copy needed (non-secret) values to you

**If you need environment variable structure:**
- Read `env.example` or similar template files
- Ask user to describe what variables are needed (without values)
- Never read the actual `.env` file

This rule has NO exceptions. Violating it requires key rotation and security remediation.

### 3. Commit Policy - NEVER COMMIT WITHOUT PERMISSION

**You may ONLY auto-commit these coordination files:**
- `docs/prd.md`
- `docs/task-list.md`
- `.claude/agent-identity.lock`
- `docs/memory/*.md` (all memory bank files)

**For ALL other files, you MUST ask permission first.** This includes:
- Implementation code (`.ts`, `.py`, `.rs`, `.go`, etc.)
- Tests (any file in `tests/`, `__tests__/`, `*_test.py`, etc.)
- Configuration files (`.json`, `.yaml`, `.toml`, `.env.example`, etc.)
- Documentation (`.md` files other than planning docs)
- Build files (`package.json`, `Cargo.toml`, `go.mod`, etc.)

**When you complete work on a PR:**
1. Tell the user what files you've modified
2. Ask: "Would you like me to commit these changes?"
3. Wait for approval
4. Only commit after user says yes

**After user approves:**
```bash
# Commit implementation (user approved)
git add [files from your PR file list]
git commit -m "clear message describing changes"

# Auto-commit task list update
git add docs/task-list.md
git commit -m "[AgentName] PR-XXX: In Progress → Complete [files]"
```

**If you're about to commit non-coordination files without asking:**
1. **STOP**
2. Ask the user first
3. Wait for response
4. Only proceed if approved

No exceptions. See `.claude/rules/commit-policy.md` for edge cases and examples.

### 4. Agent Coordination

For coding tasks, review `.claude/rules/agent-defaults.md` for how to participate in this agent coordination system.

### 5. Coding Standards - ENFORCE STRICTLY

**All code must adhere to standards defined in `.claude/rules/coding-standards.md`**

Read and follow these standards when writing or modifying code. Proactively refactor to maintain compliance.

QC agents will flag standards violations as cleanup priorities.

### 6. LLM Application Architecture

**When building LLM-powered features, follow principles in `.claude/rules/llm-architecture.md`**

This document covers:
- When to use structured outputs vs. client-side classification
- Using function calling for deterministic operations
- Prompt engineering limits and when to use structural solutions
- Logging and debugging LLM behavior

These patterns ensure robust, maintainable LLM applications.