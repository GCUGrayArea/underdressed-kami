# Memory Bank System

Claude Code agents have no memory between sessions. Each new conversation starts completely fresh. The Memory Bank provides persistent context that agents MUST read at the start of EVERY task to understand the project and continue work effectively.

## Core Principle

**Read ALL memory bank files at the start of EVERY session.** This is not optional. After each session reset, agents rely ENTIRELY on the Memory Bank to understand the project state.

## Memory Bank Location

All memory bank files are stored in `docs/memory/` and ARE committed to the repository. These files serve as **institutional memory** that benefits all users who fork or clone the project.

**Important:** Memory bank files are **agent working memory**, optimized for AI context and efficiency. They prioritize completeness and structure over human readability. Humans can read them, but they're primarily designed for agent consumption at session start.

## File Structure

Memory bank contains 4 core files that track implementation knowledge:

```
docs/memory/
├── systemPatterns.md     # Architecture, technical decisions, design patterns
├── techContext.md        # Technologies, setup, constraints, dependencies
├── activeContext.md      # Current work focus, recent changes, next steps
└── progress.md           # What works, what's left, current status, known issues
```

**Note:** Project foundation, scope, and requirements are in `docs/prd.md` (generated by `/plan`). The memory bank tracks **emergent knowledge discovered during implementation**.

### File Dependencies

```
docs/prd.md (project foundation - read first)
    └──> docs/task-list.md (work coordination - read second)
            └──> docs/memory/ (implementation wisdom - read third)
                    ├── systemPatterns.md
                    ├── techContext.md
                    ├── activeContext.md
                    └── progress.md
```

## Core Files (Required)

### 1. `systemPatterns.md`
- System architecture decisions made during implementation
- Key technical patterns that emerged
- Design patterns in use
- Component relationships
- Architectural constraints discovered

### 2. `techContext.md`
- Technologies actually being used (may differ from initial plan)
- Development setup and tooling
- Technical constraints discovered during work
- Dependencies and their purposes
- Integration points

### 3. `activeContext.md`
- Current work focus (which PRs are active)
- Recent significant changes
- Next steps and priorities
- Active decisions and open questions
- Blockers or challenges

### 4. `progress.md`
- What actually works (vs what's planned in task-list.md)
- What's left to build
- Current status of major features
- Known issues and technical debt
- Testing status

## Additional Context

Create additional files/folders within `docs/memory/` when they help organize:
- Complex feature documentation
- Integration specifications
- API documentation
- Testing strategies
- Deployment procedures

## When to Update Memory Bank

Memory bank updates occur when:

1. **Discovering new project patterns** - Architecture decisions, coding standards
2. **After implementing significant changes** - Major features, refactors, bug fixes
3. **User requests "update memory bank"** - MUST review ALL files, not just changed ones
4. **Before marking PRs as Complete** - Document what was learned/changed
5. **When context needs clarification** - Patterns becoming unclear or outdated

## Update Process

When updating memory bank:

1. **Review ALL files** - Even if some don't need updates
2. **Focus on activeContext.md and progress.md** - These track current state
3. **Document current state accurately** - What works, what doesn't
4. **Clarify next steps** - What should be done next
5. **Suggest rule changes if needed** - If you discover patterns that should be rules, SUGGEST them to the user (you cannot modify `.claude/rules/` files yourself)
6. **Commit immediately** - Memory bank files auto-commit per commit-policy.md

## Integration with Agent Coordination

When working on PRs in a multi-agent environment:

1. **Session Start:**
   - Read ALL memory bank files first
   - Then read docs/prd.md and docs/task-list.md
   - Understand both the project context AND current coordination state

2. **During Planning Phase (New PR):**
   - Reference memory bank for architecture patterns
   - Check systemPatterns.md for design consistency
   - Update activeContext.md with new considerations

3. **During Implementation:**
   - Follow patterns documented in systemPatterns.md
   - Update progress.md as features are completed
   - Document new patterns discovered during work

4. **Before Marking Complete:**
   - Update progress.md with what now works
   - Update activeContext.md with any new considerations
   - Document any new patterns in systemPatterns.md
   - Update techContext.md if new dependencies added

5. **If Suspended:**
   - Update activeContext.md with current state
   - Document partial progress in progress.md
   - Note blockers or open questions

## Learning System (.claude/rules/)

The memory bank documents "what" (project state, architecture, progress). The `.claude/rules/` directory documents "how" (agent behavior, policies, workflows).

**IMPORTANT: Agents can READ `.claude/rules/` files but CANNOT WRITE to them.** Rules files define agent behavior and constraints - allowing agents to modify them creates a security risk.

When you discover patterns that should influence how agents work:
- **Project patterns** → Update memory bank (systemPatterns.md)
- **Agent behavior policies** → SUGGEST to user (they must manually create/update .claude/rules/ files)

Examples:
- "All API endpoints use REST conventions" → systemPatterns.md
- "Always run tests before marking PR Complete" → SUGGEST creating .claude/rules/testing-policy.md to user
- "This project uses React hooks exclusively" → techContext.md
- "Agents must verify no breaking changes before committing" → SUGGEST creating .claude/rules/quality-gates.md to user
- "LLM features use structured outputs for state tracking" → systemPatterns.md (see .claude/rules/llm-architecture.md for principles)
- "All LLM tool calls are logged for debugging" → systemPatterns.md (follows .claude/rules/llm-architecture.md)

**When suggesting rule changes:**
1. Explain why the rule is needed
2. Provide the complete content the rule file should contain
3. Specify the exact file path (e.g., `.claude/rules/new-rule.md`)
4. Wait for user to manually create/update the file

## First Session Setup

**If `docs/memory/` exists:** Read all files as documented in the Session Start Checklist. This is the common case.

**If `docs/memory/` doesn't exist or core files are missing:**

1. Create the directory: `docs/memory/`
2. Create all 4 core files with basic structure
3. Populate initial content from:
   - `docs/prd.md` (project requirements and scope)
   - `docs/task-list.md` (current work state)
   - Codebase exploration (actual implementation state)
   - User discussion
4. Commit all files immediately (memory bank files auto-commit per commit-policy.md)

Once created, these files accumulate implementation knowledge over time and benefit all users of the repository.

## Session Start Checklist

Every agent session should begin with this reading order:

**1. Project Foundation (read first):**
- [ ] Read `docs/prd.md` - Project requirements and goals

**2. Work Coordination (read second):**
- [ ] Read `docs/task-list.md` - Current PRs and their status

**3. Implementation Wisdom (read third):**
- [ ] Read `docs/memory/systemPatterns.md` - Architecture decisions
- [ ] Read `docs/memory/techContext.md` - Tech stack and constraints
- [ ] Read `docs/memory/activeContext.md` - Current work focus
- [ ] Read `docs/memory/progress.md` - What works and what doesn't
- [ ] Review any additional context files in `docs/memory/`

This order ensures you understand: what we're building → what's being worked on → how we're building it.

## Why This System Exists

Claude Code agents have no memory persistence between sessions. Without the Memory Bank:
- Every session starts from zero knowledge
- Context must be rebuilt from scratch each time
- Valuable insights are lost
- Agents repeat the same discovery process

With the Memory Bank:
- Agents immediately understand project context
- Decisions and patterns are preserved
- Work continues seamlessly across sessions
- Learning accumulates over time

**The Memory Bank is the project's institutional memory.**
